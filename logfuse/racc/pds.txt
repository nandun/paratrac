

1. 目的、概要

GXP make とは、
Makefileでワークフローを記述して、
GXPを通じで各タスクを並列に処理するというシステムである。
現在、複数の実際のタスクに使われている。
これらのワークフローを、グリッドにおけるワークフローソルバーや
分散ファイルシステムの研究の際に使用できるようにする目的で
公開するとともに、それらの性質、統計データにして公開する。

2. どのようなデータを取るか

まず、ワークフローの特徴を表現するための言葉を定義しておく。

(1) ジョブ: Makefileに書かれた一行に相当するコマンド。
ジョブはシェルを通して実行される計算の最小単位である。

(2) 同一のジョブ : Makefileの同一行を解釈して投げられたジョブ。
たとえば、

Makefile:
 all: a.m b.m c.m
      touch $@
 %.m: %.txt
      cmd $<

を、a.txt, b.txt, c.txtというファイルがあるディレクトリで実行
 $ gxpc make -j 3
すると、投げられるジョブは

 1: cmd a.txt
 2: cmd b.txt
 3: cmd c.txt
 4: touch all

となるが、このとき、
   1,2,3は同一のジョブである。


同一のジョブは一つにまとめて、統計的に処理する。
それによって、ほかのデータに同じワークフローを適用した場合も、
実行時間の予測や、出力ファイルの大きさの予測などが可能となるためである。

とるデータは次のようなものを考えている。

1. ジョブの実行時間（USERとSYSTEM)
2. ジョブがファイルIOのためにブロックした総時間
3. ジョブあたりの入力ファイルの数、大きさ
4. ジョブあたりの出力ファイルの数、大きさ
5. ジョブあたりのファイルのオペレーションの回数、一回当たりの時間
        a) read, write  
        b) open, stat, readdir, remove 





3.データを取るための仕組み



まず、1のために、mkshのなかでフックして、
timeコマンドを介して実行するようにした。

/usr/time 'command'


また、2のために、FUSEを用いたログ取り専用のツール(logufuse)を使う。
入出力ファイルが置かれるディレクトリを別の場所にマウントして、データを取った。

gxpc e logfuse <source_dir> <mount_point> <log_dir>

さらに、「同一のジョブ」かどうかを判定するために、与えられたMakefileから、
コマンドを可能な限り実際の形にして、抜き出すようなツールを作る。
この方法について、次節で説明する。


最後に、コマンドラインを抜き出した後は、
state.xml に記録されている実際に投げられたジョブの
コマンドラインとの編集を測り、一番近いコマンドラインを、
そのジョブのコマンドラインとしてアサインする。


3.Makefileのパースの仕方




おおよそ次のような手順を踏む。

1.directiveのパース
[1]条件文系directive
  ifneq (1,0)
  ...(値A)
  else
  ...(値B)
  endif

[2]定義directive
  def NAME
  ...(値)
  endef


[1]は条件応じて、その場所に値を展開する。
[2]は、値をそのままの形で（中にifneqなどが入っていても関係なく）、
NAME変数に代入する。

Raccという、Yaccのruby版を用いて構文解析した。
この際、次のようなことも行う
  . #で始まるコメントを取り除く。
  . バックスラッシュでスケープされていない改行ごとに文として区切る。

2. 各行の意味の決定
directiveをパースした後、空でない各行が次のうちどれに相当するのかを
決定する。
    変数の宣言、依存関係の記述、ジョブの記述
これには、次のようなルールで、正規表現でマッチした。
 1.変数の宣言
    [行頭][(タブ,=,:)以外の文字]* (:=|=|+=|?=) (値)
 2.依存関係の記述
    [行頭][(タブ,=,:)以外の文字]* : (dependancy files)
 3.ジョブの記述
    [行頭][タブ](command_line)

3. 変数、関数の解決
  変数には次の２種類がある：
  . 変数 $(), ${}
  . 自動変数 $@, $<, ...
  また、関数は、形上は予約キーワードを用いた変数の形をしていて、
  次のようなものがある:
  $(shell command)        commandを実行してその結果を代入する
  $(word 2, foo bar baz)  "bar"
  $(dir src/foo.c hacks)  "src/ ./"
  ...

構文として、$($($()))のような階層構造をもつことがあるので、
これについてもRaccを用いた。

また、=,:=などの違いを考慮して代入する必要もある。
  :=, += などは、その場で右辺を評価して代入する。
  =, def ディレクティブなどは、その場では右辺を評価せずに代入する。


余談だが、gnu makeで、

  ab:= 1
  $(ab)c:= 2

とすると、$(1c)は2となるが、なぜか

 ab:= ell echo hoge
 c:=$(sh$(ab))

では$(c)にhogeは代入されない。


4.編集距離の適用
上述のような静的な方法では完全に同じものが作れない理由には次のようなものがある。

 関数の存在。 特に$(shell )は完全に実行時の環境依存である。

 多段 make。 引数で、`cat list`などで実行時の情報を使うことがある。

そのため、前述のように、編集距離で一番近いものを割り当てることとした。



5. 結果
実際に、ワークフローのm2mで上述のことを行った。


まず、Makefile.dataから抽出されたジョブの数は467,
そのうちまったく同じ文字列を重複とみなして除くと194だった。
これは、
747: echo "#---------------------------------------------------------------"
747: echo "# end: `date`"
747: echo "#---------------------------------------------------------------"
754: echo "#---------------------------------------------------------------"
754: echo "# begin: `date`"
のような情報を表示するためのコマンドが、変数$(BEGIN)などの展開で挿入されるためである。

さらに、そのようなものを除くために、次ようにして抽出した文字列とマッチングを行い、不必要なものを省いた。

[1]GXP makeのログである、state.txtから、実際に投入されたジョブのコマンドライン取り出した。
[2]そのコマンドラインから、fuseのログを用い、ワークフローに関与していないジョブを省いた。
ここでいう関与していないジョブとは、作業ディレクトリにおいて、ファイルの入出力を何も行っていないものである。上述のechoはその典型例である。
[3]2の結果のコマンドラインと、Makefile.dataから直接抽出した編集距離でマッチングを行った。

その結果、ジョブの数は全部で52となった。

ちなみに、そのうち、data0(入力ファイルの数が一つ)の場合、複数のジョブが同一だと判断されたのは、結局次のみだった。
13回, 985行目, "zcat  | nice -19 ../../modules/tools/enju/run-enju -so -genia | gzip > ./data-2009/medline09n0000/%.enju.gz ;  if [ `echo ${PIPESTATUS[@]} | tr -d \" \"` -ne 0 ]; then rm -f ./data-2009/medline09n0000/%.enju.gz; exit 1; fi "


この52個を、normal_cmdsとしてとっておく。

以降、data1 ... data3についても、すでにlogfuseでログはとってあるため、
このnormal_cmdsをもとに、編集距離で近いものに割り当てて、
データを集計してゆく予定である。








6. 以降
グリッドワークフロー用のmakeを作れば面白いのでは。
次のようなことをかんがえている。

1. 書きやすくする。：実行時に依存関係が必要なとき、多段makeをしなくてもよいようにする
   例 入力ファイルを数の決まっていない複数のファイルに分割して、それらに対して処理をしたい->多段makeが必要
     input => split => input.000, .... input.018
  どういう書き方がいいか？

2. map-reduce をできるようにするとか。
   あるワークフローでは、一度すべてのファイルを一つにして、ソートして、ファイルを分割していた。

3. スケジューリングができるようにする。ジョブをどのノードで実行するか指定できるようにする。









